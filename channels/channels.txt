=> channels are used to communicate data between go rountines
=> channels can also help in synchronizing the execution of go routines (one goroutine can let know another gorountine in what 
   stage of computation they are in and synchronize their execution)
=> channels are typed (they are used to send and receive data of a particular type)
=> they are thread safe, so the channel variables can be used by to send and receive values concurrently by multiple go rountines


==> declaration and initialization of channel variables <==
 declares variable  ->   var ch chan Type       --> in this case the default value of channel is nil and no memory is allocated 
 allocates memory   ->   ch = make(chan Type)   --> assigns memory to channel

                         or
                     
                         ch := make(chan Type)            --> declares and allocates memory as well



=>  pointer operator  '<-'  is used to send and receive values form the channel

ch <- v    // Send v to channel ch.

v := <-ch  // Receive from ch, and
           // assign value to v.

=> channels are blocking, the sending goroutine is going to block untill there is a corresonding receiver goroutine ready 
   to receive the value.
   Similarly the receiver goroutine is going to block until there is a corresponding sender goroutine sending the value

   and it is the responsibility of the channel to make the goroutine runnable again once it is ready to receive or send value

=> close(ch)   -> closing of the channel is very useful for the sender gouroutine to indicate to the receiver gouroutine that 
                  the sender has no more values to send on the channel and the receiver can unblock and proceed with its other computation
NOTE: closing on nil channels will panic


********** best practice for channel to avoid deadlocks ********
=> the best practice is that the goroutine that creates the channel, will be the goroutine that write to the channel and will also
   be responsible for closing the channel
=> owner of the channel is the goroutine that instantiates , writes and closes the channel
=> channel utilizers, are goroutines that only have a read-only view into the channel
****************************************************************

=> receive returns two values;
   value, ok := <- ch

   1) value  -> the first one is the value from the channel
   2) ok     -> the second is the boolean value which indicates whether the value value that is being read form the channel "is a value that is generated by the write" or "is a value that is generated by a close"


   ok = true,    -> value generated by a write
   ok = false,   -> value generated by a close



=> Technically, a channel is a data transfer pipe where data can be passed into or read from.
=> Channels by default are pointers.Mostly, when you want to communicate with a goroutine, you pass the channel as an argument 
   to the function or method. Hence when goroutine receives that channel as an argument, you donâ€™t need to dereference it to push or pull data from that channel.

=======================================================================================

==> buffered channels vs unbuffered channels <==


=> unbuffered channels (synchronous)
   ch := make(chan Type)
   => there is no buffer between the sender goroutine and receiver goroutine
   => since there is no buffer, the sender goroutine will block until there is a receiver to receive the value. The 
      receiver goroutine will block until there is a sender sending the value.

=> buffered channels (asynchronous)
   ch := make(chan Type, capacity)
   => channels are given capacity while creating using make function
   => in-memory fifo queue
   => in buffered channels there is  buffer between the sender and receiver goroutine and we can specifiy the capacity that is 
      the buffer size which indicates the number of elements that can be sent without the receiver being ready to receive the values.
   => the sender can keep sending the values without blocking till buffer gets full. when buffer gets full, the sender will block
   => the receiver can keep receiving the values wihotu blocking till buffer gets empty. when buffer gets empty, the receiver 
      will block

=========================================================================================
==> channel types <==
=> we can have send only, receive only or bidirectional channels

=> biridrectional channel
   func helper(ch chan string){               --> bidirectional channel

   }

=> 
   func helper(ch <-chan string){             --> receive only channel
       // ch can be used only to receive value
   }
=> 
   func helper(ch chan<- string){             --> send only channel
       // ch can be used only to send values
   }